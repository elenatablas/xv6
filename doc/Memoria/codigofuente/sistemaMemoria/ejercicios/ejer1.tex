%%%%%%%%%%%%%%%%%%%%%% SISTEMA DE MEMORIA - EJERCICIO 1 %%%%%%%%%%%%%%%%%%%%%%
\section{Ejercicio 1}

\subsection{Enunciado}
\begin{ejer}
    \textbf{1.[sbrk()]} Implementa la característica de reserva diferida en \texttt{xv6}.
\end{ejer}
\subsection{Desarrollo}
\subsubsection{xv6/sysproc.c}
\begin{listing}
@@ -57,10 +57,11 @@ sys_sbrk(void)
    if(argint(0, &n) < 0)
        return -1;
-   if(growproc(n) < 0)
-      return -1;
+   addr = myproc()->sz +=n;
+   myproc()->sz += n;
    return addr;
}
\end{listing}
\par Elimina la reserva de páginas de la llamada al sistema \texttt{sbrk()}, 
implementada a través de la función \texttt{sys\_sbrk()} en \texttt{sysproc.c}.
\par No llama a \texttt{growproc()} en caso de que el proceso crezca e incrementa el tamaño del proceso \texttt{myproc()->sz}.
Devuelve el tamaño antiguo, pero no reserva memoria.

\subsubsection{xv6/trap.c}
\begin{listing}
@@ -77,10 +77,39 @@ trap(struct trapframe *tf)
    case T_IRQ0 + IRQ_SPURIOUS:
        cprintf("cpu%d: spurious interrupt at %x:%x\n",
                cpuid(), tf->cs, tf->eip);
        lapiceoi();
        break;
+   case T_PGFLT:
+   {
+       pde_t *pgdir = myproc()->pgdir;
+       int oldsz = rcr2();
+       int newsz = oldsz+PGSIZE;
+       uint a = PGROUNDDOWN(oldsz); 
+       void *mem = kalloc();
+       if(mem == 0){
+           cprintf("allocuvm out of memory\n");
+           deallocuvm(pgdir, newsz, oldsz);
+           break;
+       }
+       memset(mem, 0, PGSIZE);
+       if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+           cprintf("allocuvm out of memory (2)\n");
+           deallocuvm(pgdir, newsz, oldsz);
+           kfree(mem);
+           break;
+       }
+       cprintf("pid %d %s: trap %d err %d on cpu %d "
+               "eip 0x%x addr 0x%x--kill proc\n",
+               myproc()->pid, myproc()->name, tf->trapno,
+               tf->err, cpuid(), tf->eip, rcr2());
+       break;
+   }
    //PAGEBREAK: 13
    default:
        if(myproc() == 0 || (tf->cs&3) ==0){
        // In user space, assume process misbehaved.
        cprintf("pid %d %s: trap %d err %d on cpu %d "
                "eip 0x%x addr 0x%x--kill proc\n",
                myproc()->pid, myproc()->name, tf->trapno,
                tf->err, cpuid(), tf->eip, rcr2());
        // In kernel, it must be our mistake.
        cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
                tf->trapno, cpuid(), tf->eip, rcr2());
\end{listing}
\par Modificamos el código en \texttt{trap.c} para responder a un fallo de página en 
el espacio de usuario mapeando una nueva página física en la dirección que generó el fallo,
regresando después al espacio de usuario para que continue.
\subsubsection{xv6/vm.c}
\begin{listing}
@@ -60,7 +60,7 @@ int
-   static int
+   int
    mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
    {
        char *a, *last;
\end{listing}
\par Borramos la declaración de función estática en \texttt{vm.c} para poder utilizarla en el 
fichero \texttt{trap.c}.
\subsection{Pruebas}
\subsubsection{Comando \texttt{echo}}
\begin{listing}[style=consola]
    $ 
\end{listing}
\subsubsection{Comando \texttt{ls}}
\begin{listing}[style=consola]
    $ 
\end{listing}